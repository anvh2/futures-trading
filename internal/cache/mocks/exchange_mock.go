// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package cachemock

import (
	"github.com/anvh2/futures-trading/internal/cache"
	"github.com/anvh2/futures-trading/internal/cache/exchange"
	"sync"
)

// Ensure, that ExchangeMock does implement cache.Exchange.
// If this is not the case, regenerate this file with moq.
var _ cache.Exchange = &ExchangeMock{}

// ExchangeMock is a mock implementation of cache.Exchange.
//
//	func TestSomethingThatUsesExchange(t *testing.T) {
//
//		// make and configure a mocked cache.Exchange
//		mockedExchange := &ExchangeMock{
//			GetFunc: func(symbol string) (*exchange.Symbol, error) {
//				panic("mock out the Get method")
//			},
//			SetFunc: func(symbols []*exchange.Symbol)  {
//				panic("mock out the Set method")
//			},
//			SymbolsFunc: func() []string {
//				panic("mock out the Symbols method")
//			},
//		}
//
//		// use mockedExchange in code that requires cache.Exchange
//		// and then make assertions.
//
//	}
type ExchangeMock struct {
	// GetFunc mocks the Get method.
	GetFunc func(symbol string) (*exchange.Symbol, error)

	// SetFunc mocks the Set method.
	SetFunc func(symbols []*exchange.Symbol)

	// SymbolsFunc mocks the Symbols method.
	SymbolsFunc func() []string

	// calls tracks calls to the methods.
	calls struct {
		// Get holds details about calls to the Get method.
		Get []struct {
			// Symbol is the symbol argument value.
			Symbol string
		}
		// Set holds details about calls to the Set method.
		Set []struct {
			// Symbols is the symbols argument value.
			Symbols []*exchange.Symbol
		}
		// Symbols holds details about calls to the Symbols method.
		Symbols []struct {
		}
	}
	lockGet     sync.RWMutex
	lockSet     sync.RWMutex
	lockSymbols sync.RWMutex
}

// Get calls GetFunc.
func (mock *ExchangeMock) Get(symbol string) (*exchange.Symbol, error) {
	if mock.GetFunc == nil {
		panic("ExchangeMock.GetFunc: method is nil but Exchange.Get was just called")
	}
	callInfo := struct {
		Symbol string
	}{
		Symbol: symbol,
	}
	mock.lockGet.Lock()
	mock.calls.Get = append(mock.calls.Get, callInfo)
	mock.lockGet.Unlock()
	return mock.GetFunc(symbol)
}

// GetCalls gets all the calls that were made to Get.
// Check the length with:
//
//	len(mockedExchange.GetCalls())
func (mock *ExchangeMock) GetCalls() []struct {
	Symbol string
} {
	var calls []struct {
		Symbol string
	}
	mock.lockGet.RLock()
	calls = mock.calls.Get
	mock.lockGet.RUnlock()
	return calls
}

// Set calls SetFunc.
func (mock *ExchangeMock) Set(symbols []*exchange.Symbol) {
	if mock.SetFunc == nil {
		panic("ExchangeMock.SetFunc: method is nil but Exchange.Set was just called")
	}
	callInfo := struct {
		Symbols []*exchange.Symbol
	}{
		Symbols: symbols,
	}
	mock.lockSet.Lock()
	mock.calls.Set = append(mock.calls.Set, callInfo)
	mock.lockSet.Unlock()
	mock.SetFunc(symbols)
}

// SetCalls gets all the calls that were made to Set.
// Check the length with:
//
//	len(mockedExchange.SetCalls())
func (mock *ExchangeMock) SetCalls() []struct {
	Symbols []*exchange.Symbol
} {
	var calls []struct {
		Symbols []*exchange.Symbol
	}
	mock.lockSet.RLock()
	calls = mock.calls.Set
	mock.lockSet.RUnlock()
	return calls
}

// Symbols calls SymbolsFunc.
func (mock *ExchangeMock) Symbols() []string {
	if mock.SymbolsFunc == nil {
		panic("ExchangeMock.SymbolsFunc: method is nil but Exchange.Symbols was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSymbols.Lock()
	mock.calls.Symbols = append(mock.calls.Symbols, callInfo)
	mock.lockSymbols.Unlock()
	return mock.SymbolsFunc()
}

// SymbolsCalls gets all the calls that were made to Symbols.
// Check the length with:
//
//	len(mockedExchange.SymbolsCalls())
func (mock *ExchangeMock) SymbolsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSymbols.RLock()
	calls = mock.calls.Symbols
	mock.lockSymbols.RUnlock()
	return calls
}
