package models

import (
	"encoding/json"
	"time"
)

// Signal represents a trading signal generated by analysis
type Signal struct {
	ID         string                 `json:"id"`
	Symbol     string                 `json:"symbol"`
	Type       SignalType             `json:"type"`
	Action     SignalAction           `json:"action"`
	Strength   float64                `json:"strength"`   // Signal strength (0-1)
	Confidence float64                `json:"confidence"` // Confidence level (0-1)
	Price      float64                `json:"price"`      // Signal price level
	StopLoss   float64                `json:"stop_loss,omitempty"`
	TakeProfit float64                `json:"take_profit,omitempty"`
	Timeframe  string                 `json:"timeframe"`  // e.g., "1h", "4h", "1d"
	Strategy   string                 `json:"strategy"`   // Strategy that generated signal
	Indicators map[string]float64     `json:"indicators"` // Supporting indicator values
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
	CreatedAt  time.Time              `json:"created_at"`
	ExpiresAt  time.Time              `json:"expires_at,omitempty"`
	IsActive   bool                   `json:"is_active"`
}

// SignalType represents the type of trading signal
type SignalType string

const (
	SignalTypeEntry      SignalType = "ENTRY"
	SignalTypeExit       SignalType = "EXIT"
	SignalTypeStopLoss   SignalType = "STOP_LOSS"
	SignalTypeTakeProfit SignalType = "TAKE_PROFIT"
)

// SignalAction represents the action to take
type SignalAction string

const (
	SignalActionBuy   SignalAction = "BUY"
	SignalActionSell  SignalAction = "SELL"
	SignalActionHold  SignalAction = "HOLD"
	SignalActionClose SignalAction = "CLOSE"
)

// String returns the string representation of the signal
func (s *Signal) String() string {
	data, _ := json.Marshal(s)
	return string(data)
}

// IsValid checks if the signal is valid and not expired
func (s *Signal) IsValid() bool {
	if !s.IsActive {
		return false
	}

	if !s.ExpiresAt.IsZero() && time.Now().After(s.ExpiresAt) {
		return false
	}

	return true
}

// GetIndicatorValue returns the value of a specific indicator
func (s *Signal) GetIndicatorValue(name string) (float64, bool) {
	if s.Indicators == nil {
		return 0, false
	}

	value, exists := s.Indicators[name]
	return value, exists
}

// SetIndicatorValue sets the value of a specific indicator
func (s *Signal) SetIndicatorValue(name string, value float64) {
	if s.Indicators == nil {
		s.Indicators = make(map[string]float64)
	}
	s.Indicators[name] = value
}

// GetMetadata returns a metadata value
func (s *Signal) GetMetadata(key string) (interface{}, bool) {
	if s.Metadata == nil {
		return nil, false
	}

	value, exists := s.Metadata[key]
	return value, exists
}

// SetMetadata sets a metadata value
func (s *Signal) SetMetadata(key string, value interface{}) {
	if s.Metadata == nil {
		s.Metadata = make(map[string]interface{})
	}
	s.Metadata[key] = value
}

// SignalAnalysis represents the result of signal analysis
type SignalAnalysis struct {
	Symbol         string            `json:"symbol"`
	Timeframe      string            `json:"timeframe"`
	Signals        []*Signal         `json:"signals"`
	TrendAnalysis  *TrendAnalysis    `json:"trend_analysis"`
	VolumeAnalysis *VolumeAnalysis   `json:"volume_analysis"`
	Oscillators    map[string]*Stoch `json:"oscillators"`
	Summary        *AnalysisSummary  `json:"summary"`
	GeneratedAt    time.Time         `json:"generated_at"`
}

// TrendAnalysis represents trend analysis results
type TrendAnalysis struct {
	Direction  TrendDirection `json:"direction"`
	Strength   float64        `json:"strength"`   // 0-1
	Duration   int            `json:"duration"`   // in periods
	Support    float64        `json:"support"`    // Support level
	Resistance float64        `json:"resistance"` // Resistance level
	Momentum   float64        `json:"momentum"`   // Momentum indicator
}

// TrendDirection represents the trend direction
type TrendDirection string

const (
	TrendDirectionUp       TrendDirection = "UP"
	TrendDirectionDown     TrendDirection = "DOWN"
	TrendDirectionSideways TrendDirection = "SIDEWAYS"
	TrendDirectionUnknown  TrendDirection = "UNKNOWN"
)

// VolumeAnalysis represents volume analysis results
type VolumeAnalysis struct {
	AverageVolume   float64 `json:"average_volume"`
	CurrentVolume   float64 `json:"current_volume"`
	VolumeRatio     float64 `json:"volume_ratio"`     // Current vs Average
	VolumeDirection string  `json:"volume_direction"` // INCREASING, DECREASING, STABLE
	VolumeTrend     string  `json:"volume_trend"`     // BULLISH, BEARISH, NEUTRAL
}

// AnalysisSummary provides a summary of the analysis
type AnalysisSummary struct {
	Bias              string   `json:"bias"`               // BULLISH, BEARISH, NEUTRAL
	Confidence        float64  `json:"confidence"`         // Overall confidence (0-1)
	RiskLevel         string   `json:"risk_level"`         // LOW, MEDIUM, HIGH
	RecommendedAction string   `json:"recommended_action"` // BUY, SELL, HOLD, WAIT
	Notes             []string `json:"notes"`              // Additional notes
}

// String returns the string representation of signal analysis
func (sa *SignalAnalysis) String() string {
	data, _ := json.Marshal(sa)
	return string(data)
}

// GetActiveSignals returns only active and valid signals
func (sa *SignalAnalysis) GetActiveSignals() []*Signal {
	var activeSignals []*Signal
	for _, signal := range sa.Signals {
		if signal.IsValid() {
			activeSignals = append(activeSignals, signal)
		}
	}
	return activeSignals
}

// GetSignalsByType returns signals of a specific type
func (sa *SignalAnalysis) GetSignalsByType(signalType SignalType) []*Signal {
	var filteredSignals []*Signal
	for _, signal := range sa.Signals {
		if signal.Type == signalType && signal.IsValid() {
			filteredSignals = append(filteredSignals, signal)
		}
	}
	return filteredSignals
}

// GetSignalsByAction returns signals with a specific action
func (sa *SignalAnalysis) GetSignalsByAction(action SignalAction) []*Signal {
	var filteredSignals []*Signal
	for _, signal := range sa.Signals {
		if signal.Action == action && signal.IsValid() {
			filteredSignals = append(filteredSignals, signal)
		}
	}
	return filteredSignals
}
